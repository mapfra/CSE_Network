//
// Generated file, do not edit! Created by nedtool 5.6 from AEMessage.msg.
//

#ifndef __AEMESSAGE_M_H
#define __AEMESSAGE_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



/**
 * Class generated from <tt>AEMessage.msg:2</tt> by nedtool.
 * <pre>
 * message AEMessage
 * {
 *     int URI; // this is the unique identifer of the AE, sending the message
 *     string featureType; // this is the feature type of the resource we are looking for; in this version of protocol 
 *     // we can just query one feature type per QUERY
 *     int data; // this is the value concerning the resource we are looking for; Actually used in REGISTRATION.
 *     // TO DO it will be used in UPDATE, PUT, GET, REPLY. 
 *     int flag; // this can be 
 *      // REGISTRATION (when AE register to CSE), value =0
 *      // UPDATE (when AE update every x minutes the CSE about the update in its value in local Database); value =1
 *      // CANCELLATION (when AE wants to cancel the Resource inside CSE local Database) value =2 
 *      // QUERY (when AE wants to ask for resource), value =3 
 *      // PUT (CSE to AE: CSE gives some directive to the corresponding AE) value =4 
 *      // GET (CSE to AE: CSE ask some value from the corresponding AE) value =5
 *      // REPLY (AE to CSE: AE reply to the CSE with a value normally in data) value =6 
 *      // RESPONSE (AE to CSE: AE reply to the CSE with a value normally in data) value =7 
 *      // NOTIFY between CSE to notify modifcations in route tables  value =8 
 *      // still to be asked from oneM2M experts, whether or not add the following flag
 * 
 *     int maxHop; // used for a discovery query. Number of hops for the search  
 * 
 *      // NOTE:: the packet dose not need destination URI because in our implementation it will be forwarded using Gates.
 *      // this will affect almost all the operational flags.  
 * }
 * </pre>
 */
class AEMessage : public ::omnetpp::cMessage
{
  protected:
    int URI;
    ::omnetpp::opp_string featureType;
    int data;
    int flag;
    int maxHop;

  private:
    void copy(const AEMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AEMessage&);

  public:
    AEMessage(const char *name=nullptr, short kind=0);
    AEMessage(const AEMessage& other);
    virtual ~AEMessage();
    AEMessage& operator=(const AEMessage& other);
    virtual AEMessage *dup() const override {return new AEMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getURI() const;
    virtual void setURI(int URI);
    virtual const char * getFeatureType() const;
    virtual void setFeatureType(const char * featureType);
    virtual int getData() const;
    virtual void setData(int data);
    virtual int getFlag() const;
    virtual void setFlag(int flag);
    virtual int getMaxHop() const;
    virtual void setMaxHop(int maxHop);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const AEMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, AEMessage& obj) {obj.parsimUnpack(b);}


#endif // ifndef __AEMESSAGE_M_H

